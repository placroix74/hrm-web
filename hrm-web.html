<html>
    <head>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        <style>
            div {
                margin-top: 1em;
                margin-bottom: 1em;
            }
            table {
                width: 100%;
            }
            table, th, td {
              border:1px solid black;
            }
            .list {
                width: 10em;
            }
            .code {
                width: 100%;
                text-wrap: nowrap;
            }
            .log {
                width: 30em;
            }
            .example {
                width: 100%;
                resize: none;
                overflow: hidden;
            }
            [changed] {
                background-color: lightgray;
            }
            [hidden] {
                display: none;
            }
            [success] {
                background-color: lightgreen;
            }
        </style>
    </head>
    <body style="max-width: 1024px;">
        <table>
            <tr><td colspan="3" style="text-align: center;">
                <h1>Human Resource Machine Simulator</h1>
            </td></tr>
            <tr>
                <td style="text-align: center; width: 33%;"><a href="#instructions">Instructions</a></td>
                <td style="text-align: center; width: 33%;"><a href="#opcode-reference">Programming Reference</a></td>
                <td style="text-align: center; width: 33%;"><a href="#setup-instructions">Setup File Structure</a></td>
            </tr>
        </table>
        <div id="setup-file-block">
            <label for="setup-file">Machine Setup: </label>
            <input type="file" id="setup-file" name="setup-file" />
        </div>
        <div id="setup-text-block" hidden>
        </div>
        <div id="machine">
            <table style="width: 100%;">
                <tr>
                    <th>
                        <label for="register">Register: </label><input name="register" id="register" readonly></input>
                    </td>
                    <th>
                        <label for="count">Instruction Count: </label><input name="count" id="count" readonly></input>
                    </td>
                    <th>
                        <label for="length">Program Length: </label><input name="length" id="length" readonly></input>
                    </td>
                </tr>
            </table>
            <table style="width: 100%;">
                <tr>
                    <th id="input-header">Inbox</th>
                    <th>Memory</th>
                    <th id="output-header">Outbox</th>
                    <th>Program</th>
                </tr>
                <tr>
                    <td style="width: 0%;">
                        <select id="input" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="memory" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="output" class="list" size="25"></select>
                    </td>
                    <td>
                        <textarea id="program" class="code" rows="25" spellcheck="false"></textarea>
                    </td>
                </tr>
            </table>
            <br />
            <button id="step-back" disabled>Step Back</button>
            <button id="run" disabled>Run</button>
            <button id="stop" disabled hidden>Stop</button>
            <button id="step" disabled>Step Fwd</button>
            <button id="reset" disabled>Reset</button>
            <label for="speed">Speed: </label>
            <input id="speed" name="speed" type="range" min="0" max="1000" />
        </div>
        <div id="messages">
            Messages:<br />
            <select id="message-list" class="log" size="10" style="width: 100%;"></select>
        <div />
        <div id="instructions">
            <h2>Instructions</h2>
            <ol>
                <li>Load a setup file by pressing the "Choose File" button</li>
                <li>Type/Paste your code into the "Program" text area</li>
                <li>Execute your program:</li>
                <ul>
                    <li>To launch the program, press the "Run" button</li>
                    <ul>
                        <li>To break execution of the program, press the "Stop" button</li>
                    </ul>
                    <li>To execute your program one command at a time, press the "Step Fwd" button</li>
                    <li>To roll back a command (once execution has begun), press the "Step Back" button</li>
                    <li>To restart execution from the beginning, press the "Reset" button</li>
                </ul>
                <li>Execution of the program stops automatically if:</li>
                <ul>
                    <li>A runtime error occurs; a description of the error will appear in the "Messages" list</li>
                    <li>There is no more data to read from the Inbox, i.e. the program has run successfully to completion</li>
                </ul>
            </ol>
        </div>
        <div id="opcode-reference">
            <h2>Programming Reference</h2>
            <table>
                <tr>
                    <th colspan="2"><br />Input / Output</th>
                </tr>
                <tr>
                    <td># <i>comment</i></td>
                    <td>Anything following "#" is not considered code</td>
                </tr>
                <tr>
                    <td>
                        inbox<br />
                        in
                    </td>
                    <td>Read value from Inbox into Register</td>
                </tr>
                <tr>
                    <td>
                        outbox<br />
                        out
                    </td>
                    <td>Write value from Register into Outbox</td>
                </tr>
                <tr>
                    <td>
                        copy from <i>addr</i><br />
                        from <i>addr</i>
                    </td>
                    <td>Read value from Memory slot <i>addr</i> into Register</td>
                </tr>
                <tr>
                    <td>
                        copy to <i>addr</i><br />
                        to <i>addr</i>
                    </td>
                    <td>Write value from Register into Memory slot <i>addr</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Arithmetic</th>
                </tr>
                <tr>
                    <td>add <i>addr</i></td>
                    <td>
                        Read value from Memory slot <i>addr</i> and add it to Register<br />
                        <b>NOTE:</b> Applicable to values of the same type only
                    </td>
                </tr>
                <tr>
                    <td>
                        subtract <i>addr</i><br />
                        sub <i>addr</i>
                    </td>
                    <td>
                        Read value from Memory slot <i>addr</i> and subtract it from Register<br />
                        <b>NOTE:</b> Applicable to values of the same type only
                    </td>
                </tr>
                <tr>
                    <td>
                        bump+ <i>addr</i><br />
                        increment <i>addr</i><br />
                        inc <i>addr</i>
                    </td>
                    <td>
                        Read value from Memory slot <i>addr</i> into Register, add 1 and write back to memory<br />
                        <b>NOTE:</b> Applicable to integer values only
                    </td>
                </tr>
                <tr>
                    <td>
                        bump- <i>addr</i><br />
                        decrement <i>addr</i><br />
                        dec <i>addr</i>
                    </td>
                    <td>
                        Read value from Memory slot <i>addr</i> into Register, subtract 1 and write back to memory<br />
                        <b>NOTE:</b> Applicable to integer values only
                    </td>
                </tr>
                <tr>
                    <th colspan="2"><br />Indirect Addressing</th>
                </tr>
                <tr>
                    <td><i>command</i> [<i>addr</i>]</td>
                    <td>Perform operation on Memory slot whose actual address is stored at <i>addr</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Branching</th>
                </tr>
                <tr>
                    <td><i>label</i>:</td>
                    <td>Define a jump location named <i>label</i></td>
                </tr>
                <tr>
                    <td>
                        jump <i>label</i><br />
                        jmp <i>label</i>
                    </td>
                    <td>Move program execution at <i>label</i></td>
                </tr>
                <tr>
                    <td>
                        jump if zero <i>label</i><br />
                        jump zero <i>label</i><br />
                        jumpz <i>label</i><br />
                        jzero <i>label</i><br />
                        jz <i>label</i>
                    </td>
                    <td>Move program execution at <i>label</i> if value in Register is zero</td>
                </tr>
                <tr>
                    <td>
                        jump if negative <i>label</i><br />
                        jump negative <i>label</i><br />
                        jumpn <i>label</i><br />
                        jn <i>label</i><br />
                        jlz <i>label</i>
                    </td>
                    <td>Move program execution at <i>label</i> if value in Register is negative</td>
                </tr>
                <tr>
                    <th colspan="2"><br />Constants</th>
                </tr>
                <tr>
                    <td>
                        define <i>label</i> <i>addr</i><br />
                        def <i>label</i> <i>addr</i>
                    </td>
                    <td>Define literal constant to use as Memory slot address</td>
                </tr>
            </table>
        </div>
        <div id="setup-instructions">
            <h2>Setup File Structure</h2>
            A setup file is a JSON file, which defines:<br/>
            <ul>
                <li>The problem title; if missing, the filename will be used</li>
                <li>The description of the task the program should perform, either as a string or an array of strings</li>
                <li>If applicable, a Memory initialization vector, either as:
                    <ul>
                        <li>An array up to 25 in length; if longer, extra values will be ignored</li>
                        <li>An object with memory slot addresses as keys, e.g.: <pre>{ "24": 1, ... }</pre></li>
                    </ul>
                    Missing values will be left empty
                </li>
                <li>A list of input/output datasets:</li>
                <ul>
                    <li>The initial contents of the Inbox</li>
                    <li>The <i>expected</i> contents of the Outbox, once the program has completed</li>
                </ul>
            </ul>
            The Memory initialization vector, Inbox and Outbox may only contain the following:<br/>
            <ul>
                <li>
                    Empty values, e.g.: null, ""
                </li>
                <li>
                    Integer numbers, e.g.: 10, "10"
                </li>
                <li>
                    Characters (A to Z), e.g.: "A", "B", etc.
                </li>
            </ul>
            <div>
                Example:<br />
                <textarea readonly rows="11" class="example">{
    "title": "Year 40: Sorting Floor",
    "description": "Sort the input",
    "memory": ["","","","","","","","","","","","","","","","","","","","","","","","",0],
    "datasets": [
        {
            "input": [97,35,62,0,"A","W","A","K","E",0,44,16,16,23,33,40,37,39,17,22,0,15,0],
            "output": [35,62,97,"A","A","E","K","W",16,16,17,22,23,33,37,39,40,44,15]
        }
    ]
}</textarea>
            </div>
        </div>
        <script>
                $("#setup-file").on("change", function (e) {
                    if (this.files.length === 0) {
                        console.log('No file selected.');
                    return;
                }

                window.hrmSetupFilename = this.files[0].name;

                const reader = new FileReader();
                reader.onload = function fileReadCompleted() {
                    // when the reader is done, the content is in reader.result.
                    let setup = null;
                    try {
                        setup = JSON.parse(reader.result)
                    } catch (e) {
                        logMessage(e);
                        this.files = null;
                        return;
                    }

                    setup["filename"] = window.hrmSetupFilename;

                    if (!hrmInit(setup)) {
                        this.files = null;
                    }

                    hrmRender();
                    updateUi();
                };
                reader.readAsText(this.files[0]);
            });

            $("#program").on("keyup", function (e) {
                if (window.hrmMachine != undefined && !$("#program")[0].hasAttribute("readonly")) {
                    window.hrmMachine.programChanged = true;
                }
            });

            $("#message-list").on("change", function (e) {
                let uiMessages = $("#message-list")[0];
                let value = uiMessages.value;

                uiMessages.selectedIndex = -1;

                if (value != "undefined") {
                    selectProgramLine(value);
                }
            });

            $(":button").click(function (e) {
                if (window.hrmMachine.programChanged) {
                    hrmResetState();

                    if (!hrmCompile()) {
                        return;
                    }

                    window.hrmMachine.programChanged = false;
                }

                switch (e.target.id) {
                    case "step": {
                        hrmStep();
                    } break;

                    case "step-back": {
                        hrmStepBack();
                    } break;

                    case "run": {
                        oneStep = function() {
                            if (hrmStep()) {
                                let delay = 1000 - $("#speed")[0].value;
                                window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                            } else {
                                hrmStop();
                            }

                            hrmRender();
                            updateUi();
                        };

                        $("#program")[0].setAttribute("readonly", "");

                        let delay = 1000 - $("#speed")[0].value;
                        window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                    } break;

                    case "stop": {
                        hrmStop();
                    } break;

                    case "reset": {
                        hrmResetState();
                    } break;
                }

                hrmRender();
                updateUi();
            });

            function clearMessages() {
                let uiMessages = $("#message-list");
                uiMessages[0].innerHTML = null;
            }

            function logMessage(text, value) {
                let uiMessages = $("#message-list");
                let html = `<option value=${value}>${text}</option>`;
                uiMessages.append(html);
            }

            function updateUi() {
                if (this.hrmMachine == undefined) {
                    $("#step-back")[0].setAttribute("disabled", "");
                    $("#run")[0].setAttribute("disabled", "");
                    $("#stop")[0].setAttribute("disabled", "");
                    $("#step")[0].setAttribute("disabled", "");
                    $("#reset")[0].setAttribute("disabled", "");
                } else {
                    $("#run")[0].removeAttribute("disabled");
                    $("#stop")[0].removeAttribute("disabled");

                    if (this.hrmMachine.timeoutID != null) {
                        $("#step-back")[0].setAttribute("disabled", "");
                        $("#run")[0].setAttribute("hidden", "");
                        $("#stop")[0].removeAttribute("hidden");
                        $("#step")[0].setAttribute("disabled", "");
                        $("#reset")[0].setAttribute("disabled", "");
                    } else {
                        if (this.hrmMachine.states.length > 1) {
                            $("#step-back")[0].removeAttribute("disabled");
                        } else {
                            $("#step-back")[0].setAttribute("disabled", "");
                                                    }

                        $("#run")[0].removeAttribute("hidden");
                        $("#stop")[0].setAttribute("hidden", "");
                        $("#step")[0].removeAttribute("disabled");
                        $("#reset")[0].removeAttribute("disabled");
                    }
                }
            }

            function hrmInit(setup) {
                clearMessages();

                // initialize machine

                this.hrmMachine = new Object();
                this.hrmMachine.states = [];
                this.hrmMachine.program = [];
                this.hrmMachine.programLines = [];
                this.hrmMachine.programLength = 0;
                this.hrmMachine.programChanged = true;
                this.hrmMachine.constants = [];
                this.hrmMachine.output = null;
                this.hrmMachine.timeoutID = null;

                // initial state

                let state = new Object();
                state.register = null;
                state.input = [];
                state.memory = [];
                state.output = [];

                let hasErrors = false;

                if (setup.datasets[0].input != undefined) {
                    for (entry of setup.datasets[0].input.reverse().entries()) {
                        try {
                            state.input.push(parseItem(entry[1]));
                        } catch (e) {
                            logMessage(`Invalid input value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                if (setup.memory == undefined) {
                    for (i = 0; i < 25; ++i) {
                        state.memory.push(null);
                    }
                } else {
                    for (i = 0; i < 25; ++i) {
                        try {
                            state.memory.push(parseItem(setup.memory[i]));
                        } catch (e) {
                            logMessage(`Invalid memory value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                if (setup.datasets[0].output != undefined) {
                    this.hrmMachine.output = [];

                    for (entry of setup.datasets[0].output.entries()) {
                        try {
                            this.hrmMachine.output.push(parseItem(entry[1]));
                        } catch (e) {
                            logMessage(`Invalid output value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                if (hasErrors) {
                    this.hrmMachine = undefined;
                    return false;
                }

                state.output = [];
                state.next = 0;
                state.count = 0;

                state.error = null;
                state.halted = false;
                state.register_changed = false;
                state.output_changed = false;
                state.memory_changed = false;

                this.hrmMachine.states.push(state);

                // Problem text
                $("#setup-file-block")[0].setAttribute("hidden", "");
                let uiSetupText = $("#setup-text-block");

                uiSetupText.append(`<h2>${(setup.title == undefined) ? setup.filename : setup.title}</h2>`);

                switch (typeof(setup.description)) {
                    case 'string': {
                        uiSetupText.append(`<p>${setup.description}</p>`);
                    } break;

                    case 'array': {
                        for (description of setup.description) {
                            uiSetupText.append(`<p>${description}</p>`);
                        }
                    } break;
                }

                uiSetupText[0].removeAttribute("hidden");

                // Goals
                this.hrmMachine.challenges = setup.challenges ?? new Object();

                return true;
            }

            function parseItem(item) {
                if (item == undefined) {
                    return null;
                }
                if (item == null || Number.isInteger(item)) {
                    return item;
                }
                item = item.trim();
                if (item === "") {
                    return null;
                }
                // integer as string
                let value = Number.parseInt(item);
                if (value.toString() == item.trim()) {
                    return value;
                }
                // must be a single character
                if (item.length == 1) {
                    return item.toUpperCase();
                }
                throw new Error();
            }

            function hrmRender(state) {
                if (this.hrmMachine == undefined) {
                    return;
                }
                if (state == undefined) {
                    state = hrmGetLastState();
                }

                // register

                let uiRegister = $("#register");
                uiRegister[0].value = state.register ?? "";

                if (state.register_changed) {
                    uiRegister[0].setAttribute("changed", "");
                } else {
                    uiRegister[0].removeAttribute("changed");
                }

                // instruction count

                $("#count")[0].value = state.count;

                // input

                let uiInput = $("#input");
                uiInput[0].innerHTML = null;

                for (item of state.input.toReversed()) {
                    let html = `<option>${(item ?? "")}</option>`;
                    uiInput.append(html);
                }

                let uiHeader = $("#input-header");
                if (state.input_changed) {
                    uiHeader[0].setAttribute("changed", "");
                } else {
                    uiHeader[0].removeAttribute("changed");
                }

                // memory

                let uiMemory = $("#memory");
                uiMemory[0].innerHTML = null;

                for (entry of state.memory.entries()) {
                    let item = entry[1];
                    let alias = this.hrmMachine.constants[entry[0]] ??
                        (entry[0] < 10 ? `0${entry[0]}` : entry[0].toString());
                    let html = `<option>${alias} : ${item ?? ""}</option>`;
                    uiMemory.append(html);
                }

                if (state.memory_changed !== false) {
                    let uiMemorySlot = uiMemory[0].children.item(state.memory_changed);
                    uiMemorySlot.setAttribute("changed", "");
                }

                // output

                let uiOutput = $("#output");
                uiOutput[0].innerHTML = null;

                for (item of state.output.toReversed()) {
                    let html = `<option>${item ?? ""}</option>`;
                    uiOutput.append(html);
                }

                let uiOutputHeader = $("#output-header")[0];
                if (state.output_changed) {
                    uiOutputHeader.setAttribute("changed", "");
                } else {
                    uiOutputHeader.removeAttribute("changed");
                }

                // next instruction
                selectProgramLine(state.next);

                // speed goal

                let uiCount = $("#count")[0];
                if (state.halted && this.hrmMachine.challenges.speed != undefined) {
                    uiCount.value = `${state.count} / ${this.hrmMachine.challenges.speed}`;
                    if (state.count <= this.hrmMachine.challenges.speed) {
                        uiCount.setAttribute("success", "");
                    }
                } else {
                    uiCount.value = `${state.count}`;
                    uiCount.removeAttribute("success");
                }

                // size goal

                let uiLength = $("#length")[0];
                if (state.halted && this.hrmMachine.challenges.size != undefined) {
                    uiLength.value = `${this.hrmMachine.programLength} / ${this.hrmMachine.challenges.size}`;
                    if (this.hrmMachine.programLength <= this.hrmMachine.challenges.size) {
                        uiLength.setAttribute("success", "");
                    }
                } else {
                    uiLength.value = `${this.hrmMachine.programLength}`;
                    uiLength.removeAttribute("success");
                }
            }

            function selectProgramLine(line) {
                let uiProgram = $("#program");

                // line positions
                line = Number.parseInt(line);
                let lines = this.hrmMachine.programLines;
                let start = lines[line];
                let end = lines[line + 1];

                // scroll line into view
                uiProgram[0].setSelectionRange(start, start);
                uiProgram[0].blur();
                uiProgram[0].focus();

                // select line
                uiProgram[0].setSelectionRange(start, end);
            }

            function hrmValidateOutput(state) {
                if (this.hrmMachine.output == null) {
                    return true;
                }

                for (entry of state.output.entries()) {
                    let expected = this.hrmMachine.output[entry[0]];
                    let actual = entry[1];
                    if (actual != expected) {
                        logMessage(`Bad outbox! Management expected ${expected}, but you outboxed ${actual}.`);
                        return false;
                    }
                }

                return true;
            }

            function hrmValidateFinalOutput(state) {
                if (this.hrmMachine.output == null) {
                    return true;
                }

                if (!hrmValidateOutput(state)) {
                    return false;
                }

                let expected = this.hrmMachine.output.length;
                let actual = state.output.length;
                if (actual != expected) {
                    logMessage(`Not enough stuff in the OUTBOX! Management expected a total of ${expected} items, not ${actual}!`);
                    return false;
                }

                logMessage(`Congratulations!`);
                if (this.hrmMachine.challenges.size != undefined) {
                    logMessage(`Size Challenge: use ${this.hrmMachine.challenges.size} or fewer commands. Your current solution uses ${this.hrmMachine.programLength} commands`);
                }
                if (this.hrmMachine.challenges.speed != undefined) {
                    logMessage(`Speed Challenge: complete in ${this.hrmMachine.challenges.speed} or fewer steps. Your current solution completes in ${state.count} steps`);
                }

                return true;
            }

            function hrmCompile() {
                clearMessages();

                let hasErrors = false;
                this.hrmMachine.program = [];
                this.hrmMachine.programLines = [];
                this.hrmMachine.constants = [];

                let constants = new Object();
                let labels = new Object();
                let uiProgram = $("#program");
                let programText = uiProgram[0].value;

                let lineStart = 0;

                for (line of programText.split('\n')) {
                    this.hrmMachine.programLines.push(lineStart);
                    lineStart += line.length + 1;

                    line = line
                        .replace(/\s+/g, '')  // remove all whitespace
                        .replace(/#.*$/g, '');  // remove comment

                    if (line == '') {
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    let result = null;

                    result = line.matchAll(/^DEF(INE)?([A-Z_\-]+)(\d+)$/gi).next();
                    if (!result.done) {
                        let tag = result.value[2];
                        let addr = result.value[3];
                        constants[tag.toUpperCase()] = Number.parseInt(addr);
                        this.hrmMachine.constants[addr] = tag;
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^([A-Z_\-]+):$/gi).next();
                    if (!result.done) {
                        labels[result.value[1].toUpperCase()] = this.hrmMachine.program.length;
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^IN(BOX)?$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["INBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^OUT(BOX)?$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["OUTBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^(COPY)?FROM(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[3] == undefined) ?
                            ["COPYFROM", result.value[4]] : ["pCOPYFROM", result.value[3]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^(COPY)?TO(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[3] == undefined) ?
                            ["COPYTO", result.value[4]] : ["pCOPYTO", result.value[3]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^ADD(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["ADD", result.value[3]] : ["pADD", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^SUB(TRACT)?(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[3] == undefined) ?
                            ["SUB", result.value[4]] : ["pSUB", result.value[3]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^(J(UMP)?)(IF)?(N(EG(ATIVE)?)?|L(ESSTHAN)?Z(ERO)?)([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMPIFNEGATIVE", result.value[9]]);
                        continue;
                    }

                    result = line.matchAll(/^(J(UMP)?)(IF)?(Z(ERO)?)([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMPIFZERO", result.value[6]]);
                        continue;
                    }

                    result = line.matchAll(/^(J(U)?MP)([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMP", result.value[3]]);
                        continue;
                    }

                    result = line.matchAll(/^(BUMP(UP|\+)|INC(REMENT)?)(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[5] == undefined) ?
                            ["BUMP+", result.value[6]] : ["pBUMP+", result.value[4]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^(BUMP(D(OW)?N|-)|DEC(REMENT)?)(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[6] == undefined) ?
                            ["BUMP-", result.value[7]] : ["pBUMP-", result.value[5]]
                        );
                        continue;
                    }

                    // error

                    logMessage("Syntax error", this.hrmMachine.program.length);
                    hasErrors = true;

                    this.hrmMachine.program.push(["NOP"]);
                }

                this.hrmMachine.programLines.push(programText.length);

                // resolve addresses / map labels and constants

                for (entry of this.hrmMachine.program.entries()) {
                    let item = entry[1];
                    switch (item[0]) {
                        case "COPYFROM":
                        case "pCOPYFROM":
                        case "COPYTO":
                        case "pCOPYTO":
                        case "BUMP+":
                        case "pBUMP+":
                        case "BUMP-":
                        case "pBUMP-":
                        case "ADD":
                        case "pADD":
                        case "SUB":
                        case "pSUB": {
                            let location = Number.parseInt(item[1]);
                            if (location.toString() === item[1]) {
                                item[1] = location;  // address is a number
                            } else {
                                location = constants[item[1].toUpperCase()];
                                if (location == undefined) {
                                    logMessage(`Unrecognized constant: \"${item[1]}\"`, entry[0]);
                                    hasErrors = true;
                                } else {
                                    item[1] = location;
                                }
                            }
                        } break;

                        case "JUMP":
                        case "JUMPIFZERO":
                        case "JUMPIFNEGATIVE": {
                            let location = labels[item[1].toUpperCase()];
                            if (location == undefined) {
                                logMessage(`Unrecognized jump location: \"${item[1]}\"`, entry[0]);
                                hasErrors = true;
                            } else {
                                item[1] = location;
                            }
                        } break;
                    }
                }

                this.hrmMachine.programLength = 0;

                if (hasErrors) {
                    this.hrmMachine.program = [];
                    return false;
                }

                // remove trailing NOP's
                while (this.hrmMachine.program.length > 0) {
                    let lastInstruction = this.hrmMachine.program[this.hrmMachine.program.length - 1];
                    if (lastInstruction[0] != "NOP") {
                        break;
                    }
                    this.hrmMachine.program.pop();
                }

                // program length
                for (item of this.hrmMachine.program) {
                    if (item[0] == "NOP")
                        continue;
                    ++this.hrmMachine.programLength;
                }

                return true;
            }

            function hrmGetLastState() {
                if (this.hrmMachine == undefined || this.hrmMachine.states.length == 0) {
                    return null;
                }
                return this.hrmMachine.states[this.hrmMachine.states.length - 1];
            }

            function hrmResetState() {
                if (this.hrmMachine != undefined) {
                    this.hrmMachine.states = this.hrmMachine.states.slice(0, 1);
                }
                clearMessages();
            }

            function hrmResetProgram() {
                if (this.hrmMachine != undefined) {
                    this.hrmMachine.program = [];
                    $("#length")[0].value = null;
                }
            }

            function hrmStop() {
                if (window.hrmMachine.timeoutID != null) {
                    clearTimeout(window.hrmMachine.timeoutID);
                }

                window.hrmMachine.timeoutID = null;
                $("#program")[0].removeAttribute("readonly");
            }

            function hrmStepBack() {
                if (this.hrmMachine.states.length <= 1) {
                    return;
                }

                clearMessages();

                this.hrmMachine.states.pop();
            }


            function hrmStep() {
                clearMessages();

                let state = hrmGetLastState();
                if (state.halted) {
                    return false;
                }

                let instruction = this.hrmMachine.program[state.next];
                if (instruction == undefined) {
                    logMessage("End of program reached");
                    hrmValidateFinalOutput(state);
                    return false;
                }

                let nextState = cloneState(state);
                hrmExec(nextState, instruction);
                if (nextState.error) {
                    return false;
                }

                this.hrmMachine.states.push(nextState);
                if (nextState.halted) {
                    hrmValidateFinalOutput(nextState);
                    return false;
                }

                hrmValidateOutput(nextState);
                return true;
            }

            function cloneState(state) {
                return JSON.parse(JSON.stringify(state));
            }

            function hrmGetRegister(state, operation) {
                let value = state.register;
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with an empty register!`;
                }
                return value;
            }

            function hrmGetMemory(state, slot, operation) {
                if (0 > slot || slot >= 25) {
                    state.error = `Bad tile address! Tile with address ${slot} doesn't even exist! Where do you think you're going?`;
                    return null;
                }

                let value = state.memory[slot];
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with an empty slot in Memory! Try writing something in that slot first.`;
                }
                return value;
            }

            function hrmValidateOperation(operation, operand1, operand2) {
                switch (operation) {
                    case "SUB": {
                        if (typeof(operand1) != typeof(operand2)) {
                            state.error = `You can't SUB with mixed operands! SUB'ing between one letter and one number is invalid. Only nice respectable pairs of two letters or two numbers allowed.`;
                        }
                    } break;

                    case "ADD": {
                        if (!Number.isInteger(operand1) || !Number.isInteger(operand2)) {
                            state.error = `You can't ADD with a letter! What would that even mean?!`;
                        }
                    } break;

                    case "BUMP+":
                    case "BUMP-": {
                        if (!Number.isInteger(operand1)) {
                            state.error = `You can't ${operation} with a letter! What would that even mean?!`;
                        }
                    } break;
                }

                return (state.error == null);
            }

            function hrmExec(state, instruction) {
                // indirect addressing
                let operation = instruction[0];
                switch (operation) {
                    case "pCOPYFROM":
                    case "pCOPYTO":
                    case "pADD":
                    case "pSUB":
                    case "pBUMP+":
                    case "pBUMP-": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && !Number.isInteger(value)) {
                            state.error = `Bad tile address! You can't indirect to a tile with a letter like "${value}". Only numbers allowed! Where do you think you're going?`;
                        }

                        if (state.error != null) {
                            break;
                        }
                        instruction = [operation.slice(1), value];
                    }
                }

                state.register_changed = false;
                state.input_changed = false;
                state.output_changed = false;
                state.memory_changed = false;

                // execute step

                operation = instruction[0];
                switch (operation) {
                    case "NOP": {
                        // do nothing
                    } break;

                    case "INBOX": {
                        let input = state.input.pop();
                        if (input == undefined) {
                            logMessage(state.error ?? "End of input reached");
                            state.halted = true;
                            return state;
                        }

                        state.register = input;
                        state.register_changed = true;
                        state.input_changed = true;
                    } break;

                    case "OUTBOX": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.output.push(value);
                            state.register_changed = true;
                            state.output_changed = true;
                        }
                    } break;

                    case "COPYFROM": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null) {
                            state.register = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "COPYTO": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.memory[instruction[1]] = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "ADD": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1], operation);
                            if (operand1 != null && hrmValidateOperation(operation, operand1, operand2)) {
                                state.register = operand1 + operand2;
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "SUB": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1]);
                            if (operand1 != null && hrmValidateOperation(operation, operand1, operand2)) {
                                state.register = (Number.isInteger(operand1)) ?
                                    operand1 - operand2 : operand1.charCodeAt(0) - operand2.charCodeAt(0);
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "BUMP+": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(operation, value)) {
                            state.register = state.memory[instruction[1]] = value + 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "BUMP-": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(operation, value)) {
                            state.register = state.memory[instruction[1]] = value - 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;
                }

                // set next instruction pointer

                switch (operation) {
                    case "JUMP": {
                        state.next = instruction[1];
                    } break;

                    case "JUMPIFZERO": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value == 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    case "JUMPIFNEGATIVE": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value < 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    default: {
                        ++state.next;
                    }
                }

                if (state.error != null) {
                    logMessage(state.error, state.next);
                } else {
                    ++state.count;
                }

                return state;
            }
        </script>
    </body>
</html>
