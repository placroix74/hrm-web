<html>
    <head>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        <style>
            div {
                margin-top: 1em;
                margin-bottom: 1em;
            }
            table {
                width: 100%;
            }
            table, th, td {
              border:1px solid black;
            }
            .list {
                width: 10em;
            }
            .code {
                width: 100%;
                text-wrap: nowrap;
            }
            .log {
                width: 30em;
            }
            .example {
                width: 100%;
                resize: none;
                overflow: hidden;
            }
            [changed] {
                background-color: lightgray;
            }
            [hidden] {
                display: none;
            }
            [success] {
                background-color: lightgreen;
            }
        </style>
    </head>
    <body style="max-width: 1024px;">
        <table>
            <tr><td colspan="3" style="text-align: center;">
                <h1>Human Resource Machine Simulator</h1>
            </td></tr>
            <tr>
                <td style="text-align: center; width: 33%;"><a href="#instructions">Instructions</a></td>
                <td style="text-align: center; width: 33%;"><a href="#opcode-reference">Programming Reference</a></td>
                <td style="text-align: center; width: 33%;"><a href="#setup-instructions">Setup File Structure</a></td>
            </tr>
        </table>
        <div id="setup-file-block">
            <label for="setup-file">Machine Setup: </label>
            <input type="file" id="setup-file" name="setup-file" />
        </div>
        <div id="setup-text-block" hidden>
        </div>
        <div id="machine">
            <table style="width: 100%;">
                <tr>
                    <th>
                        <label for="register">In hand: </label><input name="register" id="register" readonly></input>
                    </td>
                    <th>
                        <label for="count">Execution Steps: </label><input name="count" id="count" readonly></input>
                    </td>
                    <th>
                        <label for="length">Program Size: </label><input name="length" id="length" readonly></input>
                    </td>
                </tr>
            </table>
            <table style="width: 100%;">
                <tr>
                    <th id="input-header">Inbox</th>
                    <th>Floor Tiles</th>
                    <th id="output-header">Outbox</th>
                    <th>Program</th>
                </tr>
                <tr>
                    <td style="width: 0%;">
                        <select id="input" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="memory" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="output" class="list" size="25"></select>
                    </td>
                    <td>
                        <textarea id="program" class="code" rows="25" spellcheck="false"></textarea>
                    </td>
                </tr>
            </table>
            <br />
            <button id="step-back" disabled>Step Back</button>
            <button id="run" disabled>Run</button>
            <button id="stop" disabled hidden>Stop</button>
            <button id="step" disabled>Step Fwd</button>
            <button id="reset" disabled>Reset</button>
            <label for="speed">Speed: </label>
            <input id="speed" name="speed" type="range" min="0" max="1000" />
        </div>
        <div id="messages">
            Messages:<br />
            <select id="message-list" class="log" size="10" style="width: 100%;"></select>
        <div />
        <div id="instructions">
            <h2>Instructions</h2>
            <ol>
                <li>Load a setup file by pressing the "Choose File" button</li>
                <li>Type/Paste your code into the "Program" text area</li>
                <li>Execute your program:</li>
                <ul>
                    <li>To launch the program, press the "Run" button</li>
                    <ul>
                        <li>To break execution of the program, press the "Stop" button</li>
                    </ul>
                    <li>To execute your program one command at a time, press the "Step Fwd" button</li>
                    <li>To roll back a command (once execution has begun), press the "Step Back" button</li>
                    <li>To restart execution from the beginning, press the "Reset" button</li>
                </ul>
                <li>Execution of the program stops automatically if:</li>
                <ul>
                    <li>A runtime error occurs; a description of the error will appear in the "Messages" list</li>
                    <li>There is no more data to read from the Inbox, i.e. the program has run successfully to completion</li>
                </ul>
            </ol>
        </div>
        <div id="opcode-reference">
            <h2>Programming Reference</h2>
            <table>
                <tr>
                    <th colspan="2"><br />Input / Output</th>
                </tr>
                <tr>
                    <td>-- <i>comment</i></td>
                    <td>Anything following "--" is not considered code, anywhere on a line</td>
                </tr>
                <tr>
                    <td>INBOX</td>
                    <td>Pick up next value from the Inbox</td>
                </tr>
                <tr>
                    <td>OUTBOX</td>
                    <td>Put currently held value in the Outbox</td>
                </tr>
                <tr>
                    <td>COPYFROM <i>address</i></td>
                    <td>Pick up contents of tile at <i>address</i></td>
                </tr>
                <tr>
                    <td>COPYTO <i>address</i></td>
                    <td>Write currently held value on tile at <i>address</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Arithmetic</th>
                </tr>
                <tr>
                    <td>ADD <i>address</i></td>
                    <td>
                        Add contents of tile at <i>address</i> to currently held value<br />
                        <b>NOTE:</b> Only numbers can be added
                    </td>
                </tr>
                <tr>
                    <td>SUB <i>address</i></td>
                    <td>
                        Subtract contents of tile at <i>address</i> from currently held value<br />
                        <b>NOTE:</b> Only numbers can be subtracted from numbers, or letters from letters
                    </td>
                </tr>
                <tr>
                    <td>BUMPUP <i>address</i></td>
                    <td>
                        Subtract one to the tile at <i>address</i> and pick up the result<br />
                        <b>NOTE:</b> Only numbers can be bumped
                    </td>
                </tr>
                <tr>
                    <td>BUMPDN <i>address</i></td>
                    <td>
                        Subtract one from the tile at <i>address</i> and pick up the result<br />
                        <b>NOTE:</b> Only numbers can be bumped
                    </td>
                </tr>
                <tr>
                    <th colspan="2"><br />Indirect Addressing</th>
                </tr>
                <tr>
                    <td><i>command</i> [<i>address</i>]</td>
                    <td>Access contents of a tile whose address is written on tile at <i>address</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Branching</th>
                </tr>
                <tr>
                    <td><i>label</i>:</td>
                    <td>Define a jump location named <i>label</i></td>
                </tr>
                <tr>
                    <td>JUMP <i>label</i></td>
                    <td>Continue program execution from <i>label</i></td>
                </tr>
                <tr>
                    <td>JUMPZ <i>label</i></td>
                    <td>
                        Jump to <i>label</i> if currently held value is zero<br />
                        <b>NOTE:</b> Does nothing unless the value in hand is a number
                    </td>
                </tr>
                <tr>
                    <td>JUMPN <i>label</i></td>
                    <td>
                        Jump to <i>label</i> if currently held value is negative<br />
                        <b>NOTE:</b> Does nothing unless the value in hand is a number
                    </td>
                </tr>
                <tr>
                    <th colspan="2"><br />Tile naming</th>
                </tr>
                <tr>
                    <td>DEFINE LABEL <i>address</i> <i>label</i></td>
                    <td>Label the tile at <i>address</i></td>
                </tr>
            </table>
        </div>
        <div id="setup-instructions">
            <h2>Setup File Structure</h2>
            A setup file is a JSON file, which defines:<br/>
            <ul>
                <li>The problem title; if missing, the filename will be used</li>
                <li>The description of the task the program should perform, either as a string or an array of strings</li>
                <li>The floor size; if omitted, the default of 25</li>
                <li>The contents of floor tiles, either as:
                    <ul>
                        <li>An array; values beyond the specified size will be ignored</li>
                        <li>An object with tile addresses as keys, e.g.: <pre>{ "24": 1, ... }</pre></li>
                    </ul>
                    Missing values will be left empty
                </li>
                <li>A list of input/output datasets:</li>
                <ul>
                    <li>The initial contents of the Inbox</li>
                    <li>The <i>expected</i> contents of the Outbox, once the program has completed</li>
                </ul>
            </ul>
            The Floor Tiles, Inbox and Outbox may only contain the following:<br/>
            <ul>
                <li>
                    Empty values, e.g.: null, ""
                </li>
                <li>
                    Integer numbers, e.g.: 10, "10"
                </li>
                <li>
                    Characters (A to Z), e.g.: "A", "B", etc.
                </li>
            </ul>
            <div>
                Example:<br />
                <textarea readonly rows="11" class="example">{
    "title": "Year 40: Sorting Floor",
    "description": "Sort the input",
    "memory": {
        "size": 25,
        "contents": {"24": 0}
    },
    "datasets": [
        {
            "input": [97,35,62,0,"A","W","A","K","E",0,44,16,16,23,33,40,37,39,17,22,0,15,0],
            "output": [35,62,97,"A","A","E","K","W",16,16,17,22,23,33,37,39,40,44,15]
        }
    ]
}</textarea>
            </div>
        </div>
        <script>
                $("#setup-file").on("change", function (e) {
                    if (this.files.length === 0) {
                        console.log('No file selected.');
                    return;
                }

                window.hrmSetupFilename = this.files[0].name;

                const reader = new FileReader();
                reader.onload = function fileReadCompleted() {
                    // when the reader is done, the content is in reader.result.
                    let setup = null;
                    try {
                        setup = JSON.parse(reader.result)
                    } catch (e) {
                        logMessage(e);
                        this.files = null;
                        return;
                    }

                    setup["filename"] = window.hrmSetupFilename.slice(0, window.hrmSetupFilename.lastIndexOf('.'));

                    if (!hrmInit(setup)) {
                        this.files = null;
                    }

                    hrmRender();
                    updateUi();
                };
                reader.readAsText(this.files[0]);
            });

            $("#program").on("keyup", function (e) {
                if (window.hrmMachine != undefined && !$("#program")[0].hasAttribute("readonly")) {
                    window.hrmMachine.programChanged = true;
                }
            });

            $("#message-list").on("change", function (e) {
                let uiMessages = $("#message-list")[0];
                let value = uiMessages.value;

                uiMessages.selectedIndex = -1;

                if (value != "undefined") {
                    selectProgramLine(value);
                }
            });

            $(":button").click(function (e) {
                if (window.hrmMachine.programChanged) {
                    hrmResetState();

                    if (!hrmCompile()) {
                        return;
                    }

                    window.hrmMachine.programChanged = false;
                }

                switch (e.target.id) {
                    case "step": {
                        hrmStep();
                    } break;

                    case "step-back": {
                        hrmStepBack();
                    } break;

                    case "run": {
                        oneStep = function() {
                            if (hrmStep()) {
                                let delay = 1000 - $("#speed")[0].value;
                                window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                            } else {
                                hrmStop();
                            }

                            hrmRender();
                            updateUi();
                        };

                        $("#program")[0].setAttribute("readonly", "");

                        let delay = 1000 - $("#speed")[0].value;
                        window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                    } break;

                    case "stop": {
                        hrmStop();
                    } break;

                    case "reset": {
                        hrmResetState();
                    } break;
                }

                hrmRender();
                updateUi();
            });

            function clearMessages() {
                let uiMessages = $("#message-list");
                uiMessages[0].innerHTML = null;
            }

            function logMessage(text, value) {
                let uiMessages = $("#message-list");
                let html = `<option value=${value}>${text}</option>`;
                uiMessages.append(html);
            }

            function updateUi() {
                if (this.hrmMachine == undefined) {
                    $("#step-back")[0].setAttribute("disabled", "");
                    $("#run")[0].setAttribute("disabled", "");
                    $("#stop")[0].setAttribute("disabled", "");
                    $("#step")[0].setAttribute("disabled", "");
                    $("#reset")[0].setAttribute("disabled", "");
                } else {
                    $("#run")[0].removeAttribute("disabled");
                    $("#stop")[0].removeAttribute("disabled");

                    if (this.hrmMachine.timeoutID != null) {
                        $("#step-back")[0].setAttribute("disabled", "");
                        $("#run")[0].setAttribute("hidden", "");
                        $("#stop")[0].removeAttribute("hidden");
                        $("#step")[0].setAttribute("disabled", "");
                        $("#reset")[0].setAttribute("disabled", "");
                    } else {
                        if (this.hrmMachine.states.length > 1) {
                            $("#step-back")[0].removeAttribute("disabled");
                        } else {
                            $("#step-back")[0].setAttribute("disabled", "");
                                                    }

                        $("#run")[0].removeAttribute("hidden");
                        $("#stop")[0].setAttribute("hidden", "");
                        $("#step")[0].removeAttribute("disabled");
                        $("#reset")[0].removeAttribute("disabled");
                    }
                }
            }

            function hrmInit(setup) {
                clearMessages();

                // initialize machine

                this.hrmMachine = new Object();
                this.hrmMachine.states = [];
                this.hrmMachine.program = [];
                this.hrmMachine.programLines = [];
                this.hrmMachine.programLength = 0;
                this.hrmMachine.programChanged = true;
                this.hrmMachine.constants = [];
                this.hrmMachine.output = null;
                this.hrmMachine.timeoutID = null;

                // initial state

                let state = new Object();
                state.register = null;
                state.input = [];
                state.memory = [];
                state.output = [];

                let hasErrors = false;

                if (typeof(setup.datasets) == 'string') {
                    setup.datasets = eval(setup.datasets);

                    if (typeof(setup.datasets) == 'function') {
                        let datasets = [setup.datasets()];
                        setup.datasets = datasets;
                    }
                }

                if (setup.datasets[0]?.input != undefined) {
                    for (entry of setup.datasets[0].input.reverse().entries()) {
                        try {
                            state.input.push(parseItem(entry[1]));
                        } catch (e) {
                            logMessage(`Invalid input value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                this.hrmMachine.memorySize = setup.memory?.size ?? 25;
                if (setup.memory?.contents == undefined) {
                    for (i = 0; i < this.hrmMachine.memorySize; ++i) {
                        state.memory.push(null);
                    }
                } else {
                    for (i = 0; i < this.hrmMachine.memorySize; ++i) {
                        try {
                            state.memory.push(parseItem(setup.memory.contents[i]));
                        } catch (e) {
                            logMessage(`Invalid memory value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                if (setup.datasets[0]?.output != undefined) {
                    this.hrmMachine.output = [];

                    for (entry of setup.datasets[0]?.output.entries()) {
                        try {
                            this.hrmMachine.output.push(parseItem(entry[1]));
                        } catch (e) {
                            logMessage(`Invalid output value #${entry[0]} : ${entry[1]}`);
                            hasErrors = true;
                        }
                    }
                }

                if (hasErrors) {
                    this.hrmMachine = undefined;
                    return false;
                }

                state.output = [];
                state.next = 0;
                state.count = 0;

                state.error = null;
                state.halted = false;
                state.register_changed = false;
                state.output_changed = false;
                state.memory_changed = false;

                this.hrmMachine.states.push(state);

                // Problem text
                $("#setup-file-block")[0].setAttribute("hidden", "");
                let uiSetupText = $("#setup-text-block");

                uiSetupText.append(`<h2>${(setup.title == undefined) ? setup.filename : setup.title}</h2>`);

                switch (typeof(setup.description)) {
                    case 'undefined':
                    case 'null': {
                        // nothing to do
                    } break;

                    case 'string': {
                        uiSetupText.append(`<p>${setup.description}</p>`);
                    } break;

                    default: {
                        for (description of setup.description) {
                            uiSetupText.append(`<p>${description}</p>`);
                        }
                    }
                }

                uiSetupText[0].removeAttribute("hidden");

                // Goals
                this.hrmMachine.challenges = setup.challenges ?? new Object();

                return true;
            }

            function parseItem(item) {
                if (item == undefined) {
                    return null;
                }
                if (item == null || Number.isInteger(item)) {
                    return item;
                }
                item = item.trim();
                if (item === "") {
                    return null;
                }
                // integer as string
                let value = Number.parseInt(item);
                if (value.toString() == item.trim()) {
                    return value;
                }
                // must be a single character
                if (item.length == 1) {
                    return item.toUpperCase();
                }
                throw new Error();
            }

            function hrmRender(state) {
                if (this.hrmMachine == undefined) {
                    return;
                }
                if (state == undefined) {
                    state = hrmGetLastState();
                }

                // register

                let uiRegister = $("#register");
                uiRegister[0].value = state.register ?? "";

                if (state.register_changed) {
                    uiRegister[0].setAttribute("changed", "");
                } else {
                    uiRegister[0].removeAttribute("changed");
                }

                // instruction count

                $("#count")[0].value = state.count;

                // input

                let uiInput = $("#input");
                uiInput[0].innerHTML = null;

                for (item of state.input.toReversed()) {
                    let html = `<option>${(item ?? "")}</option>`;
                    uiInput.append(html);
                }

                let uiHeader = $("#input-header");
                if (state.input_changed) {
                    uiHeader[0].setAttribute("changed", "");
                } else {
                    uiHeader[0].removeAttribute("changed");
                }

                // memory

                let uiMemory = $("#memory");
                uiMemory[0].innerHTML = null;

                for (entry of state.memory.entries()) {
                    let item = entry[1];
                    let alias = this.hrmMachine.constants[entry[0]] ??
                        (entry[0] < 10 ? `0${entry[0]}` : entry[0].toString());
                    let html = `<option>${alias} : ${item ?? ""}</option>`;
                    uiMemory.append(html);
                }

                if (state.memory_changed !== false) {
                    let uiMemorySlot = uiMemory[0].children.item(state.memory_changed);
                    uiMemorySlot.setAttribute("changed", "");
                }

                // output

                let uiOutput = $("#output");
                uiOutput[0].innerHTML = null;

                for (item of state.output.toReversed()) {
                    let html = `<option>${item ?? ""}</option>`;
                    uiOutput.append(html);
                }

                let uiOutputHeader = $("#output-header")[0];
                if (state.output_changed) {
                    uiOutputHeader.setAttribute("changed", "");
                } else {
                    uiOutputHeader.removeAttribute("changed");
                }

                // next instruction
                selectProgramLine(state.next);

                // speed goal

                let uiCount = $("#count")[0];
                if (state.halted && this.hrmMachine.challenges.speed != undefined) {
                    uiCount.value = `${state.count} / ${this.hrmMachine.challenges.speed}`;
                    if (state.count <= this.hrmMachine.challenges.speed) {
                        uiCount.setAttribute("success", "");
                    }
                } else {
                    uiCount.value = `${state.count}`;
                    uiCount.removeAttribute("success");
                }

                // size goal

                let uiLength = $("#length")[0];
                if (state.halted && this.hrmMachine.challenges.size != undefined) {
                    uiLength.value = `${this.hrmMachine.programLength} / ${this.hrmMachine.challenges.size}`;
                    if (this.hrmMachine.programLength <= this.hrmMachine.challenges.size) {
                        uiLength.setAttribute("success", "");
                    }
                } else {
                    uiLength.value = `${this.hrmMachine.programLength}`;
                    uiLength.removeAttribute("success");
                }
            }

            function selectProgramLine(line) {
                let uiProgram = $("#program");

                // line positions
                line = Number.parseInt(line);
                let lines = this.hrmMachine.programLines;
                let start = lines[line];
                let end = lines[line + 1];

                // scroll line into view
                uiProgram[0].setSelectionRange(start, start);
                uiProgram[0].blur();
                uiProgram[0].focus();

                // select line
                uiProgram[0].setSelectionRange(start, end);
            }

            function hrmValidateOutput(state) {
                if (this.hrmMachine.output == null) {
                    return true;
                }

                for (entry of state.output.entries()) {
                    let expected = this.hrmMachine.output[entry[0]];
                    let actual = entry[1];
                    if (actual != expected) {
                        state.error = `Bad outbox! Management expected ${expected}, but you outboxed ${actual}.`;
                        return false;
                    }
                }

                return true;
            }

            function hrmValidateFinalOutput(state) {
                if (this.hrmMachine.output == null) {
                    return true;
                }

                if (!hrmValidateOutput(state)) {
                    return false;
                }

                let expected = this.hrmMachine.output.length;
                let actual = state.output.length;
                if (actual != expected) {
                    logMessage(`Not enough stuff in the OUTBOX! Management expected a total of ${expected} items, not ${actual}!`);
                    return false;
                }

                logMessage(`Congratulations!`);
                if (this.hrmMachine.challenges.size != undefined) {
                    logMessage(`Size Challenge: use ${this.hrmMachine.challenges.size} or fewer commands. Your current solution uses ${this.hrmMachine.programLength} commands`);
                }
                if (this.hrmMachine.challenges.speed != undefined) {
                    logMessage(`Speed Challenge: complete in ${this.hrmMachine.challenges.speed} or fewer steps. Your current solution completes in ${state.count} steps`);
                }

                return true;
            }

            function hrmCompile() {
                clearMessages();

                let hasErrors = false;
                this.hrmMachine.program = [];
                this.hrmMachine.programLines = [];
                this.hrmMachine.constants = [];

                let constants = new Object();
                let labels = new Object();
                let uiProgram = $("#program");
                let programText = uiProgram[0].value;

                let lineStart = 0;

                for (line of programText.split('\n')) {
                    this.hrmMachine.programLines.push(lineStart);
                    lineStart += line.length + 1;

                    line = line
                        .replace(/\s+/g, '')  // remove all whitespace
                        .replace(/--.*$/g, '');  // remove comment

                    if (line == '') {
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    let result = null;

                    result = line.matchAll(/^DEFINELABEL(\d+)([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        let address = result.value[1];
                        let name = result.value[2];
                        constants[name.toUpperCase()] = Number.parseInt(address);
                        this.hrmMachine.constants[address] = name;
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^([A-Z_\-]+):$/gi).next();
                    if (!result.done) {
                        labels[result.value[1].toUpperCase()] = this.hrmMachine.program.length;
                        this.hrmMachine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^INBOX$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["INBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^OUTBOX$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["OUTBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^COPYFROM(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["COPYFROM", result.value[3]] : ["pCOPYFROM", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^COPYTO(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["COPYTO", result.value[3]] : ["pCOPYTO", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^ADD(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["ADD", result.value[3]] : ["pADD", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^SUB(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["SUB", result.value[3]] : ["pSUB", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^JUMPN([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMP IF NEGATIVE", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^JUMPZ([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMP IF ZERO", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^JUMP([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push(["JUMP", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^BUMPUP(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["BUMP+", result.value[3]] : ["pBUMP+", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^BUMPDN(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        this.hrmMachine.program.push((result.value[2] == undefined) ?
                            ["BUMP-", result.value[3]] : ["pBUMP-", result.value[2]]
                        );
                        continue;
                    }

                    // error

                    logMessage("Syntax error", this.hrmMachine.program.length);
                    hasErrors = true;

                    this.hrmMachine.program.push(["NOP"]);
                }

                this.hrmMachine.programLines.push(programText.length);

                // resolve addresses / map labels and constants

                for (entry of this.hrmMachine.program.entries()) {
                    let item = entry[1];
                    switch (item[0]) {
                        case "COPYFROM":
                        case "pCOPYFROM":
                        case "COPYTO":
                        case "pCOPYTO":
                        case "BUMP+":
                        case "pBUMP+":
                        case "BUMP-":
                        case "pBUMP-":
                        case "ADD":
                        case "pADD":
                        case "SUB":
                        case "pSUB": {
                            let location = Number.parseInt(item[1]);
                            if (location.toString() === item[1]) {
                                item[1] = location;  // address is a number
                            } else {
                                location = constants[item[1].toUpperCase()];
                                if (location == undefined) {
                                    logMessage(`Unrecognized constant: \"${item[1]}\"`, entry[0]);
                                    hasErrors = true;
                                } else {
                                    item[1] = location;
                                }
                            }
                        } break;

                        case "JUMP":
                        case "JUMP IF ZERO":
                        case "JUMP IF NEGATIVE": {
                            let location = labels[item[1].toUpperCase()];
                            if (location == undefined) {
                                logMessage(`Unrecognized jump location: \"${item[1]}\"`, entry[0]);
                                hasErrors = true;
                            } else {
                                item[1] = location;
                            }
                        } break;
                    }
                }

                this.hrmMachine.programLength = 0;

                if (hasErrors) {
                    this.hrmMachine.program = [];
                    return false;
                }

                // remove trailing NOP's
                while (this.hrmMachine.program.length > 0) {
                    let lastInstruction = this.hrmMachine.program[this.hrmMachine.program.length - 1];
                    if (lastInstruction[0] != "NOP") {
                        break;
                    }
                    this.hrmMachine.program.pop();
                }

                // program length
                for (item of this.hrmMachine.program) {
                    if (item[0] == "NOP")
                        continue;
                    ++this.hrmMachine.programLength;
                }

                return true;
            }

            function hrmGetLastState() {
                if (this.hrmMachine == undefined || this.hrmMachine.states.length == 0) {
                    return null;
                }
                return this.hrmMachine.states[this.hrmMachine.states.length - 1];
            }

            function hrmResetState() {
                if (this.hrmMachine != undefined) {
                    this.hrmMachine.states = this.hrmMachine.states.slice(0, 1);
                }
                clearMessages();
            }

            function hrmResetProgram() {
                if (this.hrmMachine != undefined) {
                    this.hrmMachine.program = [];
                    $("#length")[0].value = null;
                }
            }

            function hrmStop() {
                if (window.hrmMachine.timeoutID != null) {
                    clearTimeout(window.hrmMachine.timeoutID);
                }

                window.hrmMachine.timeoutID = null;
                $("#program")[0].removeAttribute("readonly");
            }

            function hrmStepBack() {
                if (this.hrmMachine.states.length <= 1) {
                    return;
                }

                clearMessages();

                this.hrmMachine.states.pop();
            }


            function hrmStep() {
                clearMessages();

                let state = hrmGetLastState();
                if (state.halted) {
                    return false;
                }

                let instruction = this.hrmMachine.program[state.next];
                if (instruction == undefined) {
                    logMessage("End of program reached");
                    hrmValidateFinalOutput(state);
                    return false;
                }

                let nextState = cloneState(state);
                hrmExec(nextState, instruction);
                if (nextState.error) {
                    return false;
                }

                this.hrmMachine.states.push(nextState);
                if (nextState.halted) {
                    hrmValidateFinalOutput(nextState);
                    return false;
                }

                return true;
            }

            function cloneState(state) {
                return JSON.parse(JSON.stringify(state));
            }

            function hrmGetRegister(state, operation) {
                let value = state.register;
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with empty hands!`;
                }
                return value;
            }

            function hrmGetMemory(state, slot, operation) {
                if (0 > slot || slot >= this.hrmMachine.memorySize) {
                    state.error = `Bad tile address! Tile with address ${slot} doesn't even exist! Where do you think you're going?`;
                    return null;
                }

                let value = state.memory[slot];
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with an empty tile! Try writing something to that tile first.`;
                }
                return value;
            }

            function hrmValidateOperation(state, operation, operand1, operand2) {
                switch (operation) {
                    case "SUB": {
                        if (typeof(operand1) != typeof(operand2)) {
                            state.error = `You can't SUB with mixed operands! SUB'ing between one letter and one number is invalid. Only nice respectable pairs of two letters or two numbers allowed.`;
                        }
                    } break;

                    case "ADD": {
                        if (!Number.isInteger(operand1) || !Number.isInteger(operand2)) {
                            state.error = `You can't ADD with a letter! What would that even mean?!`;
                        }
                    } break;

                    case "BUMP+":
                    case "BUMP-": {
                        if (!Number.isInteger(operand1)) {
                            state.error = `You can't ${operation} with a letter! What would that even mean?!`;
                        }
                    } break;
                }

                return (state.error == null);
            }

            function hrmExec(state, instruction) {
                // indirect addressing
                let operation = instruction[0];
                switch (operation) {
                    case "pCOPYFROM":
                    case "pCOPYTO":
                    case "pADD":
                    case "pSUB":
                    case "pBUMP+":
                    case "pBUMP-": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && !Number.isInteger(value)) {
                            state.error = `Bad tile address! You can't indirect to a tile with a letter like "${value}". Only numbers allowed! Where do you think you're going?`;
                        }

                        if (state.error != null) {
                            break;
                        }
                        instruction = [operation.slice(1), value];
                    }
                }

                state.register_changed = false;
                state.input_changed = false;
                state.output_changed = false;
                state.memory_changed = false;

                // execute step

                operation = instruction[0];
                switch (operation) {
                    case "NOP": {
                        // do nothing
                    } break;

                    case "INBOX": {
                        let input = state.input.pop();
                        if (input == undefined) {
                            logMessage(state.error ?? "End of input reached");
                            state.halted = true;
                            return state;
                        }

                        state.register = input;
                        state.register_changed = true;
                        state.input_changed = true;
                    } break;

                    case "OUTBOX": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.output.push(value);
                            state.register_changed = true;
                            state.output_changed = true;

                            hrmValidateOutput(state);
                        }
                    } break;

                    case "COPYFROM": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null) {
                            state.register = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "COPYTO": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.memory[instruction[1]] = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "ADD": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1], operation);
                            if (operand1 != null && hrmValidateOperation(state, operation, operand1, operand2)) {
                                state.register = operand1 + operand2;
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "SUB": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1]);
                            if (operand1 != null && hrmValidateOperation(state, operation, operand1, operand2)) {
                                state.register = (Number.isInteger(operand1)) ?
                                    operand1 - operand2 : operand1.charCodeAt(0) - operand2.charCodeAt(0);
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "BUMP+": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(state, operation, value)) {
                            state.register = state.memory[instruction[1]] = value + 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "BUMP-": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(state, operation, value)) {
                            state.register = state.memory[instruction[1]] = value - 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;
                }

                // set next instruction pointer

                switch (operation) {
                    case "JUMP": {
                        state.next = instruction[1];
                    } break;

                    case "JUMP IF ZERO": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value == 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    case "JUMP IF NEGATIVE": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value < 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    default: {
                        ++state.next;
                    }
                }

                if (state.error != null) {
                    logMessage(state.error, state.next);
                } else if (operation != "NOP") {
                    ++state.count;
                }

                return state;
            }
        </script>
    </body>
</html>
