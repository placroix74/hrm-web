<html>
    <head>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        <style>
            div {
                margin-top: 1em;
                margin-bottom: 1em;
            }
            table {
                width: 100%;
            }
            table, th, td {
              border:1px solid black;
            }
            .list {
                width: 10em;
            }
            .code {
                width: 100%;
                text-wrap: nowrap;
            }
            .log {
                width: 30em;
            }
            .example {
                width: 100%;
                resize: none;
                overflow: hidden;
            }
            [changed] {
                background-color: lightgray;
            }
            [hidden] {
                display: none;
            }
            [success] {
                background-color: lightgreen;
            }
        </style>
    </head>
    <body style="max-width: 1024px;">
        <table>
            <tr><td colspan="3" style="text-align: center;">
                <h1>Human Resource Machine Simulator</h1>
            </td></tr>
            <tr>
                <td style="text-align: center; width: 33%;"><a href="#instructions">Instructions</a></td>
                <td style="text-align: center; width: 33%;"><a href="#opcode-reference">Programming Reference</a></td>
                <td style="text-align: center; width: 33%;"><a href="#setup-instructions">Custom Levels</a></td>
            </tr>
        </table>
        <div id="level-selection">
            <label for="levels">Level: </label>
            <select id="levels" name="levels">
                <option>&lt;Custom&gt;</option>
            </select>
            <input type="file" id="setup-file" />
        </div>
        <div id="setup-text-block" hidden>
        </div>
        <div id="machine">
            <table style="width: 100%;">
                <tr>
                    <th>
                        <label for="register">In hand: </label><input name="register" id="register" readonly></input>
                    </td>
                    <th>
                        <label for="count">Execution Steps: </label><input name="count" id="count" readonly></input>
                    </td>
                    <th>
                        <label for="length">Program Size: </label><input name="length" id="length" readonly></input>
                    </td>
                </tr>
            </table>
            <table style="width: 100%;">
                <tr>
                    <th id="input-header">Inbox</th>
                    <th>Floor Tiles</th>
                    <th id="output-header">Outbox</th>
                    <th>Program</th>
                </tr>
                <tr>
                    <td style="width: 0%;">
                        <select id="input" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="memory" class="list" size="25"></select>
                    </td>
                    <td style="width: 0%;">
                        <select id="output" class="list" size="25"></select>
                    </td>
                    <td>
                        <textarea id="program" class="code" rows="25" spellcheck="false"></textarea>
                    </td>
                </tr>
            </table>
            <br />
            <button id="step-back" disabled>Step Back</button>
            <button id="run" disabled>Run</button>
            <button id="stop" disabled hidden>Stop</button>
            <button id="step" disabled>Step Fwd</button>
            <button id="reset" disabled>Reset</button>
            <label for="speed">Speed: </label>
            <input id="speed" name="speed" type="range" min="0" max="1000" />
        </div>
        <div id="messages">
            Messages:<br />
            <select id="message-list" class="log" size="10" style="width: 100%;"></select>
        <div />
        <div id="instructions">
            <h2>Instructions</h2>
            <ol>
                <li>Load a setup file by pressing the "Choose File" button</li>
                <li>Type/Paste your code into the "Program" text area</li>
                <li>Execute your program:</li>
                <ul>
                    <li>To launch the program, press the "Run" button</li>
                    <ul>
                        <li>To break execution of the program, press the "Stop" button</li>
                    </ul>
                    <li>To execute your program one command at a time, press the "Step Fwd" button</li>
                    <li>To roll back a command (once execution has begun), press the "Step Back" button</li>
                    <li>To restart execution from the beginning, press the "Reset" button</li>
                </ul>
                <li>Execution of the program stops automatically if:</li>
                <ul>
                    <li>A runtime error occurs; a description of the error will appear in the "Messages" list</li>
                    <li>There is no more data to read from the Inbox, i.e. the program has run successfully to completion</li>
                </ul>
            </ol>
        </div>
        <div id="opcode-reference">
            <h2>Programming Reference</h2>
            <table>
                <tr>
                    <th colspan="2"><br />Input / Output</th>
                </tr>
                <tr>
                    <td>-- <i>comment</i></td>
                    <td>Anything following "--" is not considered code, anywhere on a line</td>
                </tr>
                <tr>
                    <td>INBOX</td>
                    <td>Pick up next value from the Inbox</td>
                </tr>
                <tr>
                    <td>OUTBOX</td>
                    <td>Put currently held value in the Outbox</td>
                </tr>
                <tr>
                    <td>COPYFROM <i>address</i></td>
                    <td>Pick up contents of tile at <i>address</i></td>
                </tr>
                <tr>
                    <td>COPYTO <i>address</i></td>
                    <td>Write currently held value on tile at <i>address</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Arithmetic</th>
                </tr>
                <tr>
                    <td>ADD <i>address</i></td>
                    <td>
                        Add contents of tile at <i>address</i> to currently held value<br />
                        <b>NOTE:</b> Only numbers can be added
                    </td>
                </tr>
                <tr>
                    <td>SUB <i>address</i></td>
                    <td>
                        Subtract contents of tile at <i>address</i> from currently held value<br />
                        <b>NOTE:</b> Only numbers can be subtracted from numbers, or letters from letters
                    </td>
                </tr>
                <tr>
                    <td>BUMPUP <i>address</i></td>
                    <td>
                        Subtract one to the tile at <i>address</i> and pick up the result<br />
                        <b>NOTE:</b> Only numbers can be bumped
                    </td>
                </tr>
                <tr>
                    <td>BUMPDN <i>address</i></td>
                    <td>
                        Subtract one from the tile at <i>address</i> and pick up the result<br />
                        <b>NOTE:</b> Only numbers can be bumped
                    </td>
                </tr>
                <tr>
                    <th colspan="2"><br />Indirect Addressing</th>
                </tr>
                <tr>
                    <td><i>command</i> [<i>address</i>]</td>
                    <td>Access a tile whose address is written on tile at <i>address</i></td>
                </tr>
                <tr>
                    <th colspan="2"><br />Branching</th>
                </tr>
                <tr>
                    <td><i>label</i>:</td>
                    <td>Define a jump location named <i>label</i></td>
                </tr>
                <tr>
                    <td>JUMP <i>label</i></td>
                    <td>Continue program execution from <i>label</i></td>
                </tr>
                <tr>
                    <td>JUMPZ <i>label</i></td>
                    <td>
                        Jump to <i>label</i> if currently held value is zero<br />
                        <b>NOTE:</b> Does nothing unless the value in hand is a number
                    </td>
                </tr>
                <tr>
                    <td>JUMPN <i>label</i></td>
                    <td>
                        Jump to <i>label</i> if currently held value is negative<br />
                        <b>NOTE:</b> Does nothing unless the value in hand is a number
                    </td>
                </tr>
                <tr>
                    <th colspan="2"><br />Tile naming</th>
                </tr>
                <tr>
                    <td>DEFINE LABEL <i>address</i> <i>label</i></td>
                    <td>Label the tile at <i>address</i></td>
                </tr>
            </table>
        </div>
        <div id="setup-instructions">
            <h2>Custom Levels</h2>
            Follow the template found in the included file: "level-data.json".

            The contents of floor tiles, either as:
            <ul>
                <li>An array; values beyond the specified size will be ignored</li>
                <li>An object with tile addresses as keys, e.g.: <pre>{ "24": 1, ... }</pre></li>
            </ul>
            Missing values will be left empty.

            The Floor Tiles, Inbox and Outbox may only contain the following:<br/>
            <ul>
                <li>
                    Empty values, e.g.: null, ""
                </li>
                <li>
                    Integer numbers, e.g.: 10, "10"
                </li>
                <li>
                    Characters (A to Z), e.g.: "A", "B", etc.
                </li>
            </ul>

            Your custom level needs at least <b>one</b> example, so it can be played.
        </div>
        <script>
            $(document).ready(function() {
                onLoad = function(data) {
                    window.hrmMachine = null;
                    window.hrmCustomLevel = null;
                    window.hrmLevels = data;

                    // populate dropdown
                    uiLevels = $("#levels");
                    for (entry of window.hrmLevels.entries()) {
                        let level = entry[1];
                        if (level.cutscene == true) {
                            continue;
                        }
                        uiLevels.append(`<option value="${entry[0]}">Year ${level.number}</option>`);
                    }
                }

                fetch('level-data.json')
                    .then(function(response) {
                        return response.json();
                    })
                    .then(function(data) {
                        onLoad(data);
                    })
                    .catch(function(error) {
                        console.log('An error occurred:', error);
                    });
            });

            $("#levels").on("change", function (e) {
                let uiSetupText = $("#setup-text-block")[0].setAttribute("hidden", "");

                let uiLevelSelect = $("#levels")[0];
                let uiSetupFile = $("#setup-file")[0];

                let level;
                if (uiLevelSelect.value == "<Custom>") {
                    uiSetupFile.removeAttribute("hidden");
                    level = window.hrmCustomLevel;
                } else {
                    uiSetupFile.setAttribute("hidden", "");
                    level = window.hrmLevels[uiLevelSelect.value];
                }

                if (level != null) {
                    hrmInit(hrmCreateMachine(level));
                }

                hrmRender(window.hrmMachine);
                updateUi(window.hrmMachine);
            });

            $("#setup-file").on("change", function (e) {
                uiSetupFile = $("#setup-file")[0];
                if (uiSetupFile.files.length === 0) {
                    console.log('No file selected.');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function fileReadCompleted() {
                    // when the reader is done, the content is in reader.result.
                    try {
                        let setup = JSON.parse(reader.result)
                        if (hrmInit(hrmCreateMachine(setup))) {
                            window.hrmCustomLevel = setup;
                        } else {
                            uiSetupFile.value = null;
                        }

                        hrmRender(window.hrmMachine);
                        updateUi(window.hrmMachine);
                    } catch (e) {
                        clearMessages();
                        logMessage(e);
                        uiSetupFile.value = null;
                    }
                };
                reader.readAsText(uiSetupFile.files[0]);
            });

            $("#program").on("keyup", function (e) {
                if (window.hrmMachine != undefined && !$("#program")[0].hasAttribute("readonly")) {
                    window.hrmMachine.programChanged = true;
                }
            });

            $("#message-list").on("change", function (e) {
                let uiMessages = $("#message-list")[0];
                let value = uiMessages.value;

                uiMessages.selectedIndex = -1;

                if (value != "undefined") {
                    selectProgramLine(value);
                }
            });

            $(":button").click(function (e) {
                if (window.hrmMachine.programChanged) {
                    hrmResetState(window.hrmMachine);

                    if (!hrmCompile(window.hrmMachine, $("#program")[0].value)) {
                        return;
                    }

                    window.hrmMachine.programChanged = false;
                }

                switch (e.target.id) {
                    case "step": {
                        if (!hrmStep(window.hrmMachine)) {
                            hrmLogMachineErrors(window.hrmMachine);
                            hrmValidateFinalOutput(window.hrmMachine);
                        }
                    } break;

                    case "step-back": {
                        hrmStepBack(window.hrmMachine);
                    } break;

                    case "run": {
                        oneStep = function() {
                            if (hrmStep(window.hrmMachine)) {
                                let delay = 1000 - $("#speed")[0].value;
                                window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                            } else {
                                hrmStop(window.hrmMachine);
                                hrmLogMachineErrors(window.hrmMachine);
                                hrmValidateFinalOutput(window.hrmMachine);
                            }

                            hrmRender(window.hrmMachine);
                            updateUi(window.hrmMachine);
                        };

                        $("#program")[0].setAttribute("readonly", "");

                        let delay = 1000 - $("#speed")[0].value;
                        window.hrmMachine.timeoutID = setTimeout(oneStep, delay);
                    } break;

                    case "stop": {
                        hrmStop(window.hrmMachine);
                    } break;

                    case "reset": {
                        hrmResetState(window.hrmMachine);
                    } break;
                }

                hrmRender(window.hrmMachine);
                updateUi(window.hrmMachine);
            });

            function clone(object) {
                return JSON.parse(JSON.stringify(object));
            }

            function clearMessages() {
                let uiMessages = $("#message-list");
                uiMessages[0].innerHTML = null;
            }

            function logMessage(text, value) {
                let uiMessages = $("#message-list");
                let html = `<option value=${value}>${text}</option>`;
                uiMessages.append(html);
            }

            function updateUi(machine) {
                if (machine == null) {
                    $("#step-back")[0].setAttribute("disabled", "");
                    $("#run")[0].setAttribute("disabled", "");
                    $("#stop")[0].setAttribute("disabled", "");
                    $("#step")[0].setAttribute("disabled", "");
                    $("#reset")[0].setAttribute("disabled", "");
                } else {
                    $("#run")[0].removeAttribute("disabled");
                    $("#stop")[0].removeAttribute("disabled");

                    if (machine.timeoutID != null) {
                        $("#step-back")[0].setAttribute("disabled", "");
                        $("#run")[0].setAttribute("hidden", "");
                        $("#stop")[0].removeAttribute("hidden");
                        $("#step")[0].setAttribute("disabled", "");
                        $("#reset")[0].setAttribute("disabled", "");
                    } else {
                        if (machine.states.length > 1) {
                            $("#step-back")[0].removeAttribute("disabled");
                        } else {
                            $("#step-back")[0].setAttribute("disabled", "");
                                                    }

                        $("#run")[0].removeAttribute("hidden");
                        $("#stop")[0].setAttribute("hidden", "");
                        $("#step")[0].removeAttribute("disabled");
                        $("#reset")[0].removeAttribute("disabled");
                    }
                }
            }

            function hrmInit(machine, exampleIndex) {
                clearMessages();

                hrmInitLevel(machine, exampleIndex);

                if (machine.errors.length > 0) {
                    hrmLogMachineErrors(machine);
                    return false;
                }

                hrmSetMachine(machine);
                return true;
            }

            function hrmSetMachine(machine) {
                this.hrmMachine = machine;
                hrmInitUI(machine);
            }

            function hrmInitUI(machine) {
                let setup = machine?.setup ?? {};

                // Problem text
                let uiSetupText = $("#setup-text-block");
                uiSetupText[0].innerHTML = null;

                if (setup.name != undefined) {
                    uiSetupText.append(`<h2>${setup.name}</h2>`);
                }

                if (setup.instructions != undefined) {
                    uiSetupText.append(`<p>${setup.instructions.replace('\n', '</p><p>')}</p>`);
                }

                uiSetupText[0].removeAttribute("hidden");
            }

            function hrmCreateMachine(setup) {
                // initialize machine

                let machine = {
                    states: [],
                    program: [],
                    programLines: [],
                    programLength: 0,
                    programChanged: true,
                    constants: [],
                    output: null,
                    timeoutID: null,
                    level: setup,
                    currentExample: null,
                    errors: []
                };

                return machine;
            }

            function hrmInitLevel(machine, exampleIndex) {
                let level = machine.level ?? {};
                let examples = level.examples ?? [];

                let example = {};
                if (examples.length > 0) {
                    machine.currentExample = exampleIndex ?? Math.trunc(Math.random() * examples.length);
                    example = examples[machine.currentExample];
                }

                let inbox = [];
                if (example.inbox != undefined) {
                    for (entry of example.inbox.toReversed().entries()) {
                        try {
                            inbox.push(parseItem(entry[1]));
                        } catch (e) {
                            machine.errors.push(`Invalid inbox value #${entry[0]} : ${entry[1]}`);
                        }
                    }
                }

                let floor = [];
                let floorRows = level.floor?.rows ?? 0;
                let floorCols = level.floor?.columns ?? 0;
                machine.memorySize = floorRows * floorCols;
                if (level.floor?.tiles == undefined) {
                    for (i = 0; i < machine.memorySize; ++i) {
                        floor.push(null);
                    }
                } else {
                    for (i = 0; i < machine.memorySize; ++i) {
                        try {
                            floor.push(parseItem(level.floor.tiles[i]));
                        } catch (e) {
                            machine.errors.push(`Invalid tile value #${entry[0]} : ${entry[1]}`);
                        }
                    }
                }

                if (example.outbox != undefined) {
                    machine.output = [];

                    for (entry of example.outbox.entries()) {
                        try {
                            machine.output.push(parseItem(entry[1]));
                        } catch (e) {
                            machine.errors.push(`Invalid outbox value #${entry[0]} : ${entry[1]}`);
                        }
                    }
                }

                let state = {
                    register: null,
                    input: inbox,
                    memory: floor,
                    output: [],
                    next: 0,
                    count: 0,
                    error: null,
                    halted: false,
                    register_changed: false,
                    output_changed: false,
                    memory_changed: false
                };

                machine.states = [state];

                return machine;
            }

            function parseItem(item) {
                if (item == undefined) {
                    return null;
                }
                if (item == null || Number.isInteger(item)) {
                    return item;
                }
                item = item.trim();
                if (item === "") {
                    return null;
                }
                // integer as string
                let value = Number.parseInt(item);
                if (value.toString() == item.trim()) {
                    return value;
                }
                // must be a single character
                if (item.length == 1) {
                    return item.toUpperCase();
                }
                throw new Error();
            }

            function hrmRender(machine) {
                let state = hrmGetLastState(machine);

                // register

                let uiRegister = $("#register");
                uiRegister[0].value = state.register ?? "";

                if (state.register_changed) {
                    uiRegister[0].setAttribute("changed", "");
                } else {
                    uiRegister[0].removeAttribute("changed");
                }

                // instruction count

                $("#count")[0].value = state.count;

                // input

                let uiInput = $("#input");
                uiInput[0].innerHTML = null;

                for (item of state.input.toReversed()) {
                    let html = `<option>${(item ?? "")}</option>`;
                    uiInput.append(html);
                }

                let uiHeader = $("#input-header");
                if (state.input_changed) {
                    uiHeader[0].setAttribute("changed", "");
                } else {
                    uiHeader[0].removeAttribute("changed");
                }

                // memory

                let uiMemory = $("#memory");
                uiMemory[0].innerHTML = null;

                for (entry of state.memory.entries()) {
                    let item = entry[1];
                    let alias = machine.constants[entry[0]] ??
                        (entry[0] < 10 ? `0${entry[0]}` : entry[0].toString());
                    let html = `<option>${alias} : ${item ?? ""}</option>`;
                    uiMemory.append(html);
                }

                if (state.memory_changed !== false) {
                    let uiMemorySlot = uiMemory[0].children.item(state.memory_changed);
                    uiMemorySlot.setAttribute("changed", "");
                }

                // output

                let uiOutput = $("#output");
                uiOutput[0].innerHTML = null;

                for (item of state.output.toReversed()) {
                    let html = `<option>${item ?? ""}</option>`;
                    uiOutput.append(html);
                }

                let uiOutputHeader = $("#output-header")[0];
                if (state.output_changed) {
                    uiOutputHeader.setAttribute("changed", "");
                } else {
                    uiOutputHeader.removeAttribute("changed");
                }

                // next instruction
                selectProgramLine(state.next);

                let challenge = machine.level.challenge ?? {};

                // speed goal

                let uiCount = $("#count")[0];
                if (state.halted && challenge.speed != undefined) {
                    uiCount.value = `${state.count} / ${challenge.speed}`;
                    if (state.count <= challenge.speed) {
                        uiCount.setAttribute("success", "");
                    }
                } else {
                    uiCount.value = `${state.count}`;
                    uiCount.removeAttribute("success");
                }

                // size goal

                let uiLength = $("#length")[0];
                if (state.halted && challenge.size != undefined) {
                    uiLength.value = `${machine.programLength} / ${challenge.size}`;
                    if (machine.programLength <= challenge.size) {
                        uiLength.setAttribute("success", "");
                    }
                } else {
                    uiLength.value = `${machine.programLength}`;
                    uiLength.removeAttribute("success");
                }
            }

            function selectProgramLine(line) {
                let uiProgram = $("#program");

                // line positions
                line = Number.parseInt(line);
                let lines = this.hrmMachine.programLines;
                let start = lines[line];
                let end = lines[line + 1];

                // scroll line into view
                uiProgram[0].setSelectionRange(start, start);
                uiProgram[0].blur();
                uiProgram[0].focus();

                // select line
                uiProgram[0].setSelectionRange(start, end);
            }

            function hrmLogMachineErrors(machine) {
                for (error of machine.errors) {
                    logMessage(error);
                }
                machine.errors = [];
            }

            function hrmValidateOutput(machine, state) {
                if (machine.output == null) {
                    return true;
                }

                for (entry of state.output.entries()) {
                    let expected = machine.output[entry[0]];
                    let actual = entry[1];
                    if (actual != expected) {
                        state.error = `Bad outbox! Management expected ${expected}, but you outboxed ${actual}.`;
                        return false;
                    }
                }

                return true;
            }

            function hrmValidateFinalOutput(machine) {
                if (machine == undefined) {
                    return true;
                }
                if (machine.output == null) {
                    return true;
                }

                let state = hrmGetLastState(machine);
                if (!hrmValidateOutput(machine, state)) {
                    return false;
                }

                let expected = machine.output.length;
                let actual = state.output.length;
                if (actual != expected) {
                    logMessage(`Not enough stuff in the OUTBOX! Management expected a total of ${expected} items, not ${actual}!`);
                    return false;
                }

                // validate against other examples
                let failedExample = null;
                let examples = machine.level.examples ?? [];
                for (entry of examples.entries()) {
                    if (entry[0] == machine.currentExample) {
                        continue;
                    }

                    let example = entry[1];
                    let testMachine = clone(machine);
                    hrmInitLevel(testMachine, entry[0]);


                    if (testMachine.errors.length == 0) {
                        while (hrmStep(testMachine));
                        let lastState = hrmGetLastState(testMachine);
                        if (lastState.halted) {
                            continue;
                        }
                    }

                    // there were errors -- switch examples
                    hrmResetState(testMachine);
                    hrmSetMachine(testMachine);

                    logMessage(`Aha! Your solution works with those specific inputs... but it FAILS on other possible inputs!`);
                    logMessage(`Yes, here, I'll give you some inputs that cause your solution to fail, so you can see for yourself.`);
                    return false;
                }

                logMessage(`Congratulations!`);

                let challenge = machine.level.challenge ?? {};
                if (challenge.size != undefined) {
                    logMessage(`Size Challenge: use ${challenge.size} or fewer commands. Your current solution uses ${machine.programLength} commands`);
                }
                if (challenge.speed != undefined) {
                    logMessage(`Speed Challenge: complete in ${machine.challenges.speed} or fewer steps. Your current solution completes in ${state.count} steps`);
                }

                return true;
            }

            function hrmCompile(machine, programText) {
                clearMessages();

                let hasErrors = false;
                machine.program = [];
                machine.programLines = [];
                machine.constants = [];

                let constants = new Object();
                let labels = new Object();

                let lineStart = 0;

                for (line of programText.split('\n')) {
                    machine.programLines.push(lineStart);
                    lineStart += line.length + 1;

                    line = line
                        .replace(/\s+/g, '')  // remove all whitespace
                        .replace(/--.*$/g, '');  // remove comment

                    if (line == '') {
                        machine.program.push(["NOP"]);
                        continue;
                    }

                    let result = null;

                    result = line.matchAll(/^DEFINELABEL(\d+)([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        let address = result.value[1];
                        let name = result.value[2];
                        constants[name.toUpperCase()] = Number.parseInt(address);
                        machine.constants[address] = name;
                        machine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^([A-Z_\-]+):$/gi).next();
                    if (!result.done) {
                        labels[result.value[1].toUpperCase()] = machine.program.length;
                        machine.program.push(["NOP"]);
                        continue;
                    }

                    result = line.matchAll(/^INBOX$/gi).next();
                    if (!result.done) {
                        machine.program.push(["INBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^OUTBOX$/gi).next();
                    if (!result.done) {
                        machine.program.push(["OUTBOX"]);
                        continue;
                    }

                    result = line.matchAll(/^COPYFROM(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["COPYFROM", result.value[3]] : ["pCOPYFROM", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^COPYTO(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["COPYTO", result.value[3]] : ["pCOPYTO", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^ADD(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["ADD", result.value[3]] : ["pADD", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^SUB(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["SUB", result.value[3]] : ["pSUB", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^JUMPN([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        machine.program.push(["JUMP IF NEGATIVE", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^JUMPZ([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        machine.program.push(["JUMP IF ZERO", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^JUMP([A-Z_\-]+)$/gi).next();
                    if (!result.done) {
                        machine.program.push(["JUMP", result.value[1]]);
                        continue;
                    }

                    result = line.matchAll(/^BUMPUP(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["BUMP+", result.value[3]] : ["pBUMP+", result.value[2]]
                        );
                        continue;
                    }

                    result = line.matchAll(/^BUMPDN(\[(\d+|[A-Z_\-]+)\]|(\d+|[A-Z_\-]+))$/gi).next();
                    if (!result.done) {
                        machine.program.push((result.value[2] == undefined) ?
                            ["BUMP-", result.value[3]] : ["pBUMP-", result.value[2]]
                        );
                        continue;
                    }

                    // error

                    logMessage("Syntax error", machine.program.length);
                    hasErrors = true;

                    machine.program.push(["NOP"]);
                }

                machine.programLines.push(programText.length);

                // resolve addresses / map labels and constants

                for (entry of machine.program.entries()) {
                    let item = entry[1];
                    switch (item[0]) {
                        case "COPYFROM":
                        case "pCOPYFROM":
                        case "COPYTO":
                        case "pCOPYTO":
                        case "BUMP+":
                        case "pBUMP+":
                        case "BUMP-":
                        case "pBUMP-":
                        case "ADD":
                        case "pADD":
                        case "SUB":
                        case "pSUB": {
                            let location = Number.parseInt(item[1]);
                            if (location.toString() === item[1]) {
                                item[1] = location;  // address is a number
                            } else {
                                location = constants[item[1].toUpperCase()];
                                if (location == undefined) {
                                    logMessage(`Unrecognized constant: \"${item[1]}\"`, entry[0]);
                                    hasErrors = true;
                                } else {
                                    item[1] = location;
                                }
                            }
                        } break;

                        case "JUMP":
                        case "JUMP IF ZERO":
                        case "JUMP IF NEGATIVE": {
                            let location = labels[item[1].toUpperCase()];
                            if (location == undefined) {
                                logMessage(`Unrecognized jump location: \"${item[1]}\"`, entry[0]);
                                hasErrors = true;
                            } else {
                                item[1] = location;
                            }
                        } break;
                    }
                }

                machine.programLength = 0;

                if (hasErrors) {
                    machine.program = [];
                    return false;
                }

                // remove trailing NOP's
                while (machine.program.length > 0) {
                    let lastInstruction = machine.program[machine.program.length - 1];
                    if (lastInstruction[0] != "NOP") {
                        break;
                    }
                    machine.program.pop();
                }

                if (machine.program.length == 0) {
                    logMessage("No program");
                    return false;
                }

                // program length
                for (item of machine.program) {
                    if (item[0] == "NOP")
                        continue;
                    ++machine.programLength;
                }

                return true;
            }

            function hrmGetLastState(machine) {
                if (/*machine == null ||*/ machine.states.length == 0) {
                    return null;
                }
                return machine.states[machine.states.length - 1];
            }

            function hrmResetState(machine) {
                machine.states = machine.states.slice(0, 1);
            }

            function hrmStop(machine) {
                if (machine.timeoutID != null) {
                    clearTimeout(machine.timeoutID);
                }

                machine.timeoutID = null;
                $("#program")[0].removeAttribute("readonly");
            }

            function hrmStepBack(machine) {
                if (machine.states.length <= 1) {
                    return;
                }

                clearMessages();

                machine.states.pop();
            }


            function hrmStep(machine) {
                clearMessages();

                let state = hrmGetLastState(machine);
                if (state.halted) {
                    return false;
                }

                let instruction = machine.program[state.next];
                let nextState = clone(state);
                hrmExec(machine, nextState, instruction);
                
                if (nextState.error) {
                    machine.errors.push(nextState.error);
                    return false;
                }

                if (nextState.next == machine.program.length) {
                    logMessage("End of program reached");
                    nextState.halted = true;
                }

                machine.states.push(nextState);
                return !nextState.halted;
            }

            function hrmGetRegister(state, operation) {
                let value = state.register;
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with empty hands!`;
                }
                return value;
            }

            function hrmGetMemory(state, slot, operation) {
                if (0 > slot || slot >= state.memory.length) {
                    state.error = `Bad tile address! Tile with address ${slot} doesn't even exist! Where do you think you're going?`;
                    return null;
                }

                let value = state.memory[slot];
                if (value == null) {
                    state.error = `Empty value! You can't ${operation} with an empty tile! Try writing something to that tile first.`;
                }
                return value;
            }

            function hrmValidateOperation(state, operation, operand1, operand2) {
                switch (operation) {
                    case "SUB": {
                        if (typeof(operand1) != typeof(operand2)) {
                            state.error = `You can't SUB with mixed operands! SUB'ing between one letter and one number is invalid. Only nice respectable pairs of two letters or two numbers allowed.`;
                        }
                    } break;

                    case "ADD": {
                        if (!Number.isInteger(operand1) || !Number.isInteger(operand2)) {
                            state.error = `You can't ADD with a letter! What would that even mean?!`;
                        }
                    } break;

                    case "BUMP+":
                    case "BUMP-": {
                        if (!Number.isInteger(operand1)) {
                            state.error = `You can't ${operation} with a letter! What would that even mean?!`;
                        }
                    } break;
                }

                return (state.error == null);
            }

            function hrmExec(machine, state, instruction) {
                // indirect addressing
                let operation = instruction[0];
                switch (operation) {
                    case "pCOPYFROM":
                    case "pCOPYTO":
                    case "pADD":
                    case "pSUB":
                    case "pBUMP+":
                    case "pBUMP-": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && !Number.isInteger(value)) {
                            state.error = `Bad tile address! You can't indirect to a tile with a letter like "${value}". Only numbers allowed! Where do you think you're going?`;
                        }

                        if (state.error != null) {
                            break;
                        }
                        instruction = [operation.slice(1), value];
                    }
                }

                state.register_changed = false;
                state.input_changed = false;
                state.output_changed = false;
                state.memory_changed = false;

                // execute step

                operation = instruction[0];
                switch (operation) {
                    case "NOP": {
                        // do nothing
                    } break;

                    case "INBOX": {
                        let input = state.input.pop();
                        if (input == undefined) {
                            logMessage(state.error ?? "End of input reached");
                            state.halted = true;
                            return state;
                        }

                        state.register = input;
                        state.register_changed = true;
                        state.input_changed = true;
                    } break;

                    case "OUTBOX": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.output.push(value);
                            state.register_changed = true;
                            state.output_changed = true;

                            hrmValidateOutput(machine, state);
                        }
                    } break;

                    case "COPYFROM": {
                        let value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null) {
                            state.register = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "COPYTO": {
                        let value = hrmGetRegister(state, operation);
                        if (value != null) {
                            state.memory[instruction[1]] = value;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "ADD": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1], operation);
                            if (operand1 != null && hrmValidateOperation(state, operation, operand1, operand2)) {
                                state.register = operand1 + operand2;
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "SUB": {
                        let operand1 = hrmGetRegister(state, operation);
                        if (operand1 != null) {
                            operand2 = hrmGetMemory(state, instruction[1]);
                            if (operand1 != null && hrmValidateOperation(state, operation, operand1, operand2)) {
                                state.register = (Number.isInteger(operand1)) ?
                                    operand1 - operand2 : operand1.charCodeAt(0) - operand2.charCodeAt(0);
                                state.register_changed = true;
                                state.memory_changed = instruction[1];
                            }
                        }
                    } break;

                    case "BUMP+": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(state, operation, value)) {
                            state.register = state.memory[instruction[1]] = value + 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;

                    case "BUMP-": {
                        value = hrmGetMemory(state, instruction[1], operation);
                        if (value != null && hrmValidateOperation(state, operation, value)) {
                            state.register = state.memory[instruction[1]] = value - 1;
                            state.register_changed = true;
                            state.memory_changed = instruction[1];
                        }
                    } break;
                }

                // set next instruction pointer

                switch (operation) {
                    case "JUMP": {
                        state.next = instruction[1];
                    } break;

                    case "JUMP IF ZERO": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value == 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    case "JUMP IF NEGATIVE": {
                        let value = hrmGetRegister(state);
                        if (value != null) {
                            state.next = (Number.isInteger(value) && value < 0) ? instruction[1] : state.next + 1;
                        }
                    } break;

                    default: {
                        ++state.next;
                    }
                }

                if (state.error == null && operation != "NOP") {
                    ++state.count;
                }

                return state;
            }
        </script>
    </body>
</html>
